function varargout = trajectory_vector(varargin)
% TRAJECTORY_VECTOR M-file for trajectory_vector.fig
%      TRAJECTORY_VECTOR, by itself, creates a new TRAJECTORY_VECTOR or raises the existing
%      singleton*.
%
%      H = TRAJECTORY_VECTOR returns the handle to a new TRAJECTORY_VECTOR or the handle to
%      the existing singleton*.
%
%      TRAJECTORY_VECTOR('CALLBACK',hObject,eventData,handles,...) calls the local
%      function named CALLBACK in TRAJECTORY_VECTOR.M with the given input arguments.
%
%      TRAJECTORY_VECTOR('Property','Value',...) creates a new TRAJECTORY_VECTOR or raises the
%      existing singleton*.  Starting from the left, property value pairs are
%      applied to the GUI before trajectory_vector_OpeningFunction gets called.  An
%      unrecognized property name or invalid value makes property application
%      stop.  All inputs are passed to trajectory_vector_OpeningFcn via varargin.
%
%      *See GUI Options on GUIDE's Tools menu.  Choose "GUI allows only one
%      instance to run (singleton)".
%
% See also: GUIDE, GUIDATA, GUIHANDLES

% Edit the above text to modify the response to help trajectory_vector

% Last Modified by GUIDE v2.5 26-Jan-2011 13:43:43

% Begin initialization code - DO NOT EDIT
gui_Singleton = 1;
gui_State = struct('gui_Name',       mfilename, ...
                   'gui_Singleton',  gui_Singleton, ...
                   'gui_OpeningFcn', @trajectory_vector_OpeningFcn, ...
                   'gui_OutputFcn',  @trajectory_vector_OutputFcn, ...
                   'gui_LayoutFcn',  [] , ...
                   'gui_Callback',   []);
if nargin && ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end

if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
end
% End initialization code - DO NOT EDIT


% --- Executes just before trajectory_vector is made visible.
function trajectory_vector_OpeningFcn(hObject, eventdata, handles, varargin)
% This function has no output args, see OutputFcn.
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% varargin   command line arguments to trajectory_vector (see VARARGIN)

% Choose default command line output for trajectory_vector
handles.output = hObject;

% Update handles structure
guidata(hObject, handles);


% --- Outputs from this function are returned to the command line.
function varargout = trajectory_vector_OutputFcn(hObject, eventdata, handles) 
% varargout  cell array for returning output args (see VARARGOUT);
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get default command line output from handles structure
varargout{1} = handles.output;


% --- Executes on button press in LoadTrajectoryButton.=============================================
function LoadTrajectoryButton_Callback(hObject, eventdata, handles)
[TrajFileName,TrajPathName] = uigetfile('*.mat','Select the trajectories data');
set(handles.TrajPathString,'String',strcat(TrajPathName,TrajFileName));
handles.trajpath = [TrajPathName,TrajFileName];
guidata(hObject, handles);


% --- Executes on button press in select_ROI.=======================================================
function select_ROI_Callback(hObject, eventdata, handles)
%Any trajectory with less frames than the threshold won't be considered
frThreshold = str2double(get(handles.frThreshold,'String'));
A = load(handles.trajpath);
traj = cell(length(A.tracksFinal),1);
for i=1:length(A.tracksFinal)
    % coordinates are inverted with respect to img_sequence
    % como guarda las coordenadas u-track? (0,0) esta en el top left corner?
    traj{i}(:,1) = A.tracksFinal(i,1).tracksCoordAmpCG(1,1:8:end);
    traj{i}(:,2) = A.tracksFinal(i,1).tracksCoordAmpCG(1,2:8:end);
    %NaN indicates frames where track segments do not exist.
    ix = isnan(traj{i}(:,1));  %remove NaN
    if exist('ix','var')
        traj{i}(ix,:) = [];
    end
end
% Remove trajectories smaller than frThreshold
k=1;
for j=1:length(traj)
    if (length(traj{j}(:,1)) <= frThreshold)
        jx(k) = j;
        k = k+1;
    end
end
if exist('jx','var')
    traj(jx) = [];
end
%Segment cell
fig = figure('Name',['Trajectory Vectors - ',handles.trajpath],'NumberTitle','off');
I = imadjust(A.im/max(A.im(:)));
imshow(I);
hold on
%take positions and trajectory vectors from every particle inside ROI
%ROI_dialog();
BW = roipoly(I);
k = 1;
for i=1:length(traj)
    %if first point of trajectory is inside ROI include trajectory
    a = round(traj{i}(1,1));
    b = round(traj{i}(1,2));
    if (a == 0)                   % Convert point (0,0) to (1,1)
        a = 1; 
    elseif (b == 0) 
        b = 1; 
    elseif (BW(b, a))
        ij(k,:) = traj{i}(1,:);   % first point of the trajectory
        vect(k,:) = traj{i}(end,:) - traj{i}(1,:);
        vectNorm(k) = norm(vect(k,:));
        trajROI{k} = traj{i};
        k = k + 1;
    end
end
quiver(ij(:,1), ij(:,2), vect(:,1), vect(:,2),'r');
title('Unfiltered Trajectory vectors')
% normalize vectors
% Save global data, Ta: all traj inside the ROI
handles.I = I;
handles.Ta.traj = trajROI;             %traj inside the ROI 
handles.Ta.ij = ij;                    %first point of the traj
handles.Ta.vectNorm = vectNorm;        %Norm of the vector
handles.Ta.vect = vect;                %direction of the vector?
handles.fig = fig;                     %microscopy image
handles.Ta.N = length(trajROI);        %number of traj inside ROI
guidata(hObject, handles);


% ====Vector Analysis===============================================================================
function vect_analysis_Callback(hObject, eventdata, handles)
% load data
if (handles.linFlag)
    vect = handles.Tl.vect;
    Minusi = handles.Tl.Minusi;
    Plusi = handles.Tl.Plusi;
    N = length(handles.Tl.traj);
    ij = handles.Tl.ij;
else
    vect = handles.Ta.vect;
    Minusi = handles.Ta.Minusi;
    Plusi = handles.Ta.Plusi;
    N = length(handles.Ta.traj);
    ij = handles.Ta.ij;
end
% calculate vector length
for i=1:N
    vectNorm(i) = norm(vect(i,:));
end
% Show (+) and (-) end vectors
vectH = figure('Name', ['Plus & Minus end trajectories - ', handles.trajpath]); 
imshow(handles.I);
hold on
quiver(ij(Plusi,1), ij(Plusi,2), ...
    vect(Plusi,1), vect(Plusi,2) , 'g');
quiver(ij(Minusi,1), ij(Minusi,2), ...
    vect(Minusi,1), vect(Minusi,2) , 'r');  
if isfield(handles, 'x0')
    plot(handles.x0, handles.y0, 'x')
end
if handles.linFlag
    title('Assymetric vectors: plus-end green, minus-end red')
else
    title('Asymmetric and symmetric vectors')
    xlabel('Symmetric: plus-end cyan, minus-end yellow ; Asymmetric: plus-end green, minus-end red')
end
% Vector Statistics
x = 1:round(max(vectNorm))+1;
meanVN = mean(vectNorm);
medianVN = median(vectNorm);
modeVN = mode(vectNorm);
vectPlusNorm = vectNorm(Plusi);
vectMinusNorm = vectNorm(Minusi);
meanVP = mean(vectPlusNorm);
medianVP = median(vectPlusNorm);
modeVP = mode(vectPlusNorm);
meanVM = mean(vectMinusNorm);
medianVM = median(vectMinusNorm);
modeVM = mode(vectMinusNorm);
%save vectstat meanVN medianVN modeVN meanVP medianVP modeVP meanVM medianVM modeVM
figure('Name',['Vector Statistics - ', handles.trajpath]);
%All vectors
subplot(3,1,1)
n = hist(vectNorm, x);
[~,i] = max(n);
hist(vectNorm, x);
title(['Mean: ', num2str(meanVN), ', Median: ',num2str(medianVN), ', Mode: ',...
    num2str(x(i)), ', Number of Trajectories: ', num2str(length(vectNorm))])
xlabel('Vector length (pixels) - All trajectories')
ylabel('# of vesicles')
%Plus end vectors
subplot(3,1,2)
n = hist(vectPlusNorm, x);
[~,i] = max(n);
hist(vectPlusNorm, x)
title(['Mean: ', num2str(meanVP), ',  Median: ',num2str(medianVP), ...
    ',  Mode: ', num2str(x(i)), ', Number of Trajectories: ', num2str(length(vectPlusNorm))])
xlabel(['Trajectory length (pixels) - Plus end trajectories','   (', ...
    int2str(length(vectPlusNorm)*100/N), '% of all vesicles)'])
ylabel('# of vesicles')
%Minus end vectors
subplot(3,1,3)
n = hist(vectMinusNorm, x);
[~,i] = max(n);
hist(vectMinusNorm, x)
title(['Mean: ', num2str(meanVM), ',  Median: ',num2str(medianVM),...
    ',  Mode: ', num2str(x(i)),  ', Number of Trajectories: ', num2str(length(vectMinusNorm))])
xlabel(['Vector length (pixels) - Minus end trajectories','   (', ...
    int2str(length(vectMinusNorm)*100/N), '% of all vesicles)'])
ylabel('# of vesicles')
fileName = get(handles.file_name,'String');
print(vectH,'-dpng ',fileName);                 % Save vectors image



% --- Trajectory analysis===========================================================================
% Plots the (+) and (-) end trajectories, and calculates the distribution of it's length
function traj_analysis_Callback(hObject, eventdata, handles)
% load data
if (handles.linFlag)
    traj = handles.Tl.traj;
    Minusi = handles.Tl.Minusi;
    Plusi = handles.Tl.Plusi;
    N = length(handles.Tl.traj);
else
    traj = handles.Ta.traj;
    Minusi = handles.Ta.Minusi;
    Plusi = handles.Ta.Plusi;
    N = length(handles.Ta.traj);
end
%Calculate the contourlength 
trajCL = zeros(N,1);
k = 1;
for i=1:N
    aux = 0;
    for j=1:(length(traj{i}(:,1))-1)   %Number of trajectory points
        aux = norm(traj{i}(j+1,:)-traj{i}(j,:));
        trajCL(i) = trajCL(i) + aux;
    end
end
% Smoothing of the trajectories
trajSmooth = cell(1,N);
for i=1:N
    trajSmooth{i}(:,1) = smooth(traj{i}(:,1));
    trajSmooth{i}(:,2) = smooth(traj{i}(:,2));
end
%Plot smoothed trajectories goint to the (+) or (-) end 
figure('Name',['Trajectories - ',handles.trajpath]);
imshow(handles.I)
hold all
for i=Plusi
    if ~handles.linFlag % si no se filtra las simetricas, diferenciar entre sym y asym
        if handles.asyFlag(i)  
            plot(trajSmooth{i}(:,1), trajSmooth{i}(:,2),'g')
        else
            plot(trajSmooth{i}(:,1), trajSmooth{i}(:,2),'c')
        end
    else
        plot(trajSmooth{i}(:,1), trajSmooth{i}(:,2),'g')
    end
end
for i=Minusi
    if (~handles.linFlag) % si no se filtra las simetricas, diferenciar entre sym y asym
        if handles.asyFlag(i)  
            plot(trajSmooth{i}(:,1), trajSmooth{i}(:,2),'r')
        else
            plot(trajSmooth{i}(:,1), trajSmooth{i}(:,2),'y')
        end
    else
        plot(trajSmooth{i}(:,1), trajSmooth{i}(:,2),'r')
    end
end
if handles.linFlag
    title('Assymetric trajectories: plus-end green, minus-end red')
else
    title('Assymetric and symmetric trajectories')
    xlabel('Symetric: plus-end cyan, minus-end yellow ; Asymmetric: plus-end green, minus-end red')
end
%statics of the smoothed trajectories
x = 1:2:round(max(trajCL)) + 1;
meanTN = mean(trajCL);
medianTN = median(trajCL);
modeTN = mode(trajCL);
meanTP = mean(mean(trajCL(Plusi)));
medianTP = median(trajCL(Plusi));
modeTP = mode(trajCL(Plusi));
meanTM = mean(trajCL(Minusi));
medianTM = median(trajCL(Minusi));
modeTM = mode(trajCL(Minusi));
%save trajstat meanTN medianTN modeTN meanTP medianTP modeTP meanTM medianTM modeTM
figure('Name',['Trajectory Statistics - ',handles.trajpath]);
%All trajectories
subplot(3,1,1)
n = hist(trajCL, x);
[~,i] = max(n);
hist(trajCL, x)
title(['Mean: ', num2str(meanTN), ',  Median: ',num2str(medianTN), ...
    ',  Mode: ', num2str(x(i)), ', Number of Trajectories: ', num2str(length(trajCL))])
xlabel('Trajectory length (pixels) - All trajectories')
ylabel('# of occurrences')
%Plus end trajectories
subplot(3,1,2)
n = hist(trajCL(Plusi), x);
[~,i] = max(n);
hist(trajCL(Plusi), x)
title(['Mean: ', num2str(meanTP), ',  Median: ',num2str(medianTP), ...
    ',  Mode: ', num2str(x(i)), ', Number of Trajectories: ', num2str(length(trajCL(Plusi)))])
xlabel('Trajectory length (pixels) - Plus end trajectories')
ylabel('# of occurrences')
%Minus end trajectories
subplot(3,1,3)
n = hist(trajCL(Minusi), x);
[~,i] = max(n);
hist(trajCL(Minusi), x)
title(['Mean: ', num2str(meanTM), ',  Median: ',num2str(medianTM), ...
    ',  Mode: ', num2str(x(i)), ', Number of Trajectories: ', num2str(length(trajCL(Minusi)))])
xlabel('Trajectory length (pixels) - Minus end trajectories')
ylabel('# of occurrences')

% --- Executes on button press in Segment_analysis.
function Segment_analysis_Callback(hObject, eventdata, handles)   
pntFlag = get(handles.radio_point,'Value');
nuclFlag = get(handles.radio_nucleus,'Value');
manFlag = get(handles.radio_manual, 'Value');
handles.linFlag = get(findall(0,'Tag','asymcheck'), 'Value');
%Minus end point selection
if (pntFlag == 1)
    %minus_end_dialog();
    [handles.x0, handles.y0] = getpts(figure(handles.fig));
%Minus end cell nucleus selection
elseif (nuclFlag == 1)
    % deberia incluir un dialog
    figure(handles.fig)
    BW = roipoly(handles.I);
    L = bwlabel(BW);
    s = regionprops(L, 'centroid');
    handles.x0 = s.Centroid(1);
    handles.y0 = s.Centroid(2);
end
[handles.Tl.Plusi, handles.Tl.Minusi] = Polarity(handles.Tl.traj, ...
        handles.Tl.ij, handles.x0, handles.y0, handles);

    
% Calculate the minus end point, and separate the (-)end from the (+)end
% going vesicles====================================================================================
function apply_polarity_Callback(hObject, eventdata, handles)
% Minus end point selection
%percentile above which is considered asymetric
asymPercent = str2double(get(handles.edit6,'String'));   
pntFlag = get(handles.radio_point,'Value');
nuclFlag = get(handles.radio_nucleus,'Value');
manFlag = get(handles.radio_manual, 'Value');
handles.linFlag = get(findall(0,'Tag','asymcheck'), 'Value');
%Minus end point selection
if (pntFlag == 1)
    %minus_end_dialog();
    [handles.x0, handles.y0] = getpts(figure(handles.fig));
%Minus end cell nucleus selection
elseif (nuclFlag == 1)
    % deberia incluir un dialog
    figure(handles.fig)
    BW = roipoly(handles.I);
    L = bwlabel(BW);
    s = regionprops(L, 'centroid');
    handles.x0 = s.Centroid(1);
    handles.y0 = s.Centroid(2);
end

% Calculate asymmetry of trajectories for all methods
handles.asyFlag = false(1,handles.Ta.N);
for i=1:handles.Ta.N
    [~,handles.asyFlag(i)] = asym(handles.Ta.traj{i}, length(handles.Ta.traj{i}), asymPercent);      
end
% Get lineal trajectories
handles.Tl.traj = handles.Ta.traj(handles.asyFlag);
handles.Tl.ij = handles.Ta.ij(handles.asyFlag,:);
handles.Tl.vect = handles.Ta.vect(handles.asyFlag,:);
handles.Tl.N = length(handles.Tl.ij);
% Indexes to plus/minus-end trajectories
handles.Tl.Plusi = [];    
handles.Tl.Minusi = []; 
handles.Ta.Plusi = [];
handles.Ta.Minusi = [];
if (handles.linFlag && (pntFlag || nuclFlag))       % for linear trajectories only
    [handles.Tl.Plusi, handles.Tl.Minusi] = Polarity(handles.Tl.traj, ...
        handles.Tl.ij, handles.x0, handles.y0, handles);
elseif (~handles.linFlag && (pntFlag || nuclFlag))  % for all trajectories
    [handles.Ta.Plusi, handles.Ta.Minusi] = Polarity(handles.Ta.traj, ...
        handles.Ta.ij, handles.x0, handles.y0, handles);
elseif (handles.linFlag && manFlag)
    % manual trajectory selection for the linear traj
    figure('Name','Trajectory polarity','NumberTitle','off'); imshow(handles.I);
    hold on
    % use a for loop to get the handles of individual quiver objects instead of all of them
    for i=1:handles.Tl.N    
        quiver(handles.Tl.ij(i,1), handles.Tl.ij(i,2), handles.Tl.vect(i,1),handles.Tl.vect(i,2),...
            'ButtonDownFcn',{@quiver_ButtonDownFcn, handles.traj_vectGUI},'Color','b',...
            'AutoScaleFactor',2, 'MaxHeadSize', 1, 'HitTestArea', 'on', 'LineWidth', 0.7);
        plot(handles.Tl.traj{i}(:,1), handles.Tl.traj{i}(:,2), 'Color','c');
    end
    title('Classify linear trajectories acording to polarity')
    xlabel({'Minus-end: Left mouse button','Plus-end: Left mouse button + Ctrl'})
elseif (~handles.linFlag && manFlag)
    % manual trajectory selection for all the traj
    figure('Name','Trajectory polarity','NumberTitle','off'); imshow(handles.I);
    hold on
    for i=1:handles.Tl.N    
        quiver(handles.Ta.ij(i,1), handles.Ta.ij(i,2), handles.Ta.vect(i,1),handles.Ta.vect(i,2),...
            'ButtonDownFcn',{@quiver_ButtonDownFcn, handles.traj_vectGUI},'Color','b',...
            'AutoScaleFactor',2, 'MaxHeadSize', 1, 'HitTestArea', 'on', 'LineWidth', 0.7);
        plot(handles.Ta.traj{i}(:,1), handles.Ta.traj{i}(:,2), 'Color','c');
    end
    title('Classify all trajectories acording to polarity')
    xlabel({'Minus-end: Left mouse button','Plus-end: Left mouse button + Ctrl'})
end
if (handles.linFlag)
    vect = handles.Tl.vect;
    Minusi = handles.Tl.Minusi;
    Plusi = handles.Tl.Plusi;
    N = length(handles.Tl.traj);
    ij = handles.Tl.ij;
else
    vect = handles.Ta.vect;
    Minusi = handles.Ta.Minusi;
    Plusi = handles.Ta.Plusi;
    N = length(handles.Ta.traj);
    ij = handles.Ta.ij;
end
% calculate vector length
for i=1:N
    vectNorm(i) = norm(vect(i,:));
end

% Show (+) and (-) end vectors
handles.vectH = figure('Name', ['Plus & Minus end trajectories - ', handles.trajpath]); 
imshow(handles.I);
hold on
quiver(ij(Plusi,1), ij(Plusi,2), ...
    vect(Plusi,1), vect(Plusi,2) , 'g');
quiver(ij(Minusi,1), ij(Minusi,2), ...
    vect(Minusi,1), vect(Minusi,2) , 'r');  
if isfield(handles, 'x0')
    plot(handles.x0, handles.y0, 'x')
end
if handles.linFlag
    title('Assymetric vectors: plus-end green, minus-end red')
else
    title('Asymmetric and symmetric vectors')
    xlabel('Symmetric: plus-end cyan, minus-end yellow ; Asymmetric: plus-end green, minus-end red')
end

%save global data to handles
guidata(hObject, handles);
%Enable plot buttons
set(handles.vect_analysis, 'Enable', 'on')
set(handles.traj_analysis, 'Enable', 'on')


% Calculate polarity of trajectories on the filtered (or not) trajectories==========================
function [Plusi, Minusi] = Polarity(traj, ij, x, y, handles)
phiThresh = str2double(get(handles.edit1,'String'))*pi/180;  
j = 1;
m = 1;
for i=1:length(traj)
    % angle between vector, and radial vector pointing to it
    % podria hacerlo con el eje mayor de la variance-covariance matrix
    phi = abs(atan360(x, ij(i,1), y, ij(i,2)) - ...
        atan360(ij(i,1), traj{i}(end,1), ij(i,2), traj{i}(end,2)));
    if (min(phi, 2*pi-phi) <= phiThresh)
        Plusi(j) = i;                       % index of the +end going filtered vector
        j = j + 1;
    elseif (abs(pi-phi) <= phiThresh)
        Minusi(m) = i;                      % index of the -end going filtered vector
        m = m + 1; 
    end
end 
if ~exist('Plusi', 'var')      % if theres no plus/minus-end generate null so it wont conflict
    Plusi = [];
elseif ~exist('Minusi', 'var')
    Minusi = [];
end


% --- Otherwise, executes on mouse press in 5 pixel border or over quiver.==========================
function quiver_ButtonDownFcn(hObject, eventdata, GUIhandle)
% This callback is on the select vectors figure. That's why it's handles it's not the same as the
% GUI's. GUIhandle: Handle to the GUI figure
handles = guidata(GUIhandle);
if handles.linFlag   % If the linear checkbox is checked
    % find is about 16 times faster than using a FOR loop. Multiply arrays to do AND.
    selectionType = get(gcf, 'SelectionType');
    if strcmp(selectionType, 'normal')    % select minus-end
        handles.Tl.Minusi(length(handles.Tl.Minusi) + 1) = ...
            find((handles.Tl.ij(:,1)==get(gco,'XData')).*(handles.Tl.ij(:,2)==get(gco,'YData')));
        set(hObject,'Color','r')
    elseif strcmp(selectionType,'alt')   % select plus-end
        handles.Tl.Plusi(length(handles.Tl.Plusi) + 1) = ...
            find((handles.Tl.ij(:,1)==get(gco,'XData')).*(handles.Tl.ij(:,2)==get(gco,'YData')));
        set(hObject,'Color','g')
    end
else
    selectionType = get(gcf, 'SelectionType');
    if strcmp(selectionType, 'normal')    % select minus-end
        handles.Ta.Minusi(length(handles.Ta.Minusi) + 1) = ...
            find((handles.Ta.ij(:,1)==get(gco,'XData')).*(handles.Ta.ij(:,2)==get(gco,'YData')));
        set(hObject,'Color','r')
    elseif strcmp(selectionType,'alt')   % select plus-end
        handles.Ta.Plusi(length(handles.Ta.Plusi) + 1) = ...
            find((handles.Ta.ij(:,1)==get(gco,'XData')).*(handles.Ta.ij(:,2)==get(gco,'YData')));
        set(hObject,'Color','g')
    end
end
guidata(GUIhandle, handles);

% --- Executes on button press in save_workspace.===================================================
function save_workspace_Callback(hObject, eventdata, handles)
% Save to workspace
evalin('base', 'clear Tall Tlin');
assignin('base','Tall',handles.Ta)
assignin('base','Tlin',handles.Tl)


% --- Executes on button press in save_to_disk.
function save_to_disk_Callback(hObject, eventdata, handles)
% hObject    handle to save_to_disk (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% save(get(handles.file_name,'String'),'-struct', 'handles', 'Ta', 'Tl')
Tall = handles.Ta;
Tlin = handles.Tl;
fileName = get(handles.file_name,'String');
if ~exist([fileName,'.mat'],'file')
    save(fileName, 'Tall', 'Tlin');
else
    overwrite = overwrite_dialog();
    if overwrite
        save(fileName, 'Tall', 'Tlin');
    end
end
if isfield(handles, 'vectH')                      % Check if the vector figure handle exists
    print(handles.vectH,'-dpng ',fileName);       % Save vector figure
end


%===================================================================================================
%===================================================================================================
% --- Executes on button press in radio_nucleus.
function radio_nucleus_Callback(~, ~, ~)

% --- Executes on button press in radio_point.
function radio_point_Callback(~, ~, ~)

function pixels_Callback(~, ~, ~)

function edit1_Callback(~, ~, ~)

% --- Executes during object creation, after setting all properties.
function pixels_CreateFcn(hObject, ~, ~)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function frThreshold_Callback(hObject, eventdata, handles)

% --- Executes during object creation, after setting all properties.
function frThreshold_CreateFcn(hObject, eventdata, handles)

if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

% --- Executes during object creation, after setting all properties.
function edit1_CreateFcn(hObject, eventdata, handles)

if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

% --- Executes during object creation, after setting all properties.
function edit2_CreateFcn(hObject, eventdata, handles)

if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

% --- Executes on button press in asymcheck.
function asymcheck_Callback(hObject, eventdata, handles)

function file_name_Callback(hObject, eventdata, handles)

% --- Executes during object creation, after setting all properties.
function file_name_CreateFcn(hObject, eventdata, handles)
% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



